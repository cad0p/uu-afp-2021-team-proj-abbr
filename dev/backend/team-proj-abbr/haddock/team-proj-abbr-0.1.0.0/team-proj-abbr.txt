-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ShortHndr
--   
--   Please see the README on GitHub at
--   <a>https://github.com/cad0p/uu-afp-2021-team-proj-abbr#readme</a>
@package team-proj-abbr
@version 0.1.0.0


module LibCli.Spec
cliModes :: [ShortHndr]

-- | ShortHndr CLI interface specification.
data ShortHndr

-- | Defines the arguments for the replace command
Replace :: Maybe FilePath -> Maybe FilePath -> Bool -> Maybe FilePath -> ShortHndr
[input] :: ShortHndr -> Maybe FilePath
[out] :: ShortHndr -> Maybe FilePath

-- | specifies if changes should be written directly to input file.
[inplace] :: ShortHndr -> Bool
[kb] :: ShortHndr -> Maybe FilePath

-- | Defines the arguments for the expand command
Expand :: String -> Maybe FilePath -> ShortHndr
[abbreviation] :: ShortHndr -> String
[kb] :: ShortHndr -> Maybe FilePath

-- | Defines the arguments for the list command
List :: Maybe FilePath -> ShortHndr
[kb] :: ShortHndr -> Maybe FilePath

-- | Defines the arguments for the add command
Add :: String -> String -> Maybe FilePath -> ShortHndr
[abbreviation] :: ShortHndr -> String
[expansion] :: ShortHndr -> String
[kb] :: ShortHndr -> Maybe FilePath

-- | Defines the arguments for the update command
Update :: String -> String -> Maybe FilePath -> ShortHndr
[abbreviation] :: ShortHndr -> String
[expansion] :: ShortHndr -> String
[kb] :: ShortHndr -> Maybe FilePath

-- | Defines the arguments for the delete command
Delete :: String -> Maybe FilePath -> ShortHndr
[abbreviation] :: ShortHndr -> String
[kb] :: ShortHndr -> Maybe FilePath
instance GHC.Show.Show LibCli.Spec.ShortHndr
instance Data.Data.Data LibCli.Spec.ShortHndr


module LibCore.InputInterface
getInput :: String


module LibCore.Models

-- | We parse a string into a NoToken if it does not match the syntax for |
--   parsing. The DoMap is a string that has to be mapped. In our
--   proposals, | the DoMap strings start with @@
data Token
NoToken :: String -> Token
DoMap :: Keyword -> Token

-- | Abstract and parameterised Keyword datatype. Implements Functor and
--   Applicative typeclasses.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; pure "hello" :: AKeyword String
--   Key {keyword = "hello", plural = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (map Data.Char.toUpper) &lt;$&gt; (pure "hello" :: AKeyword String)
--   Key {keyword = "HELLO", plural = False}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (pure (map Data.Char.toLower)) &lt;*&gt; (pure "HELLO" :: AKeyword String)
--   Key {keyword = "hello", plural = False}
--   </pre>
data AKeyword a
Key :: a -> Bool -> AKeyword a
[keyword] :: AKeyword a -> a
[plural] :: AKeyword a -> Bool

-- | A Keyword is a Token that can be mapped. A Keyword can be plural
type Keyword = AKeyword String

-- | Reserved domain-level error indications.
newtype Error
StandardError :: String -> Error
instance GHC.Show.Show a => GHC.Show.Show (LibCore.Models.AKeyword a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (LibCore.Models.AKeyword a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (LibCore.Models.AKeyword a)
instance GHC.Show.Show LibCore.Models.Token
instance GHC.Classes.Ord LibCore.Models.Token
instance GHC.Classes.Eq LibCore.Models.Token
instance GHC.Show.Show LibCore.Models.Error
instance GHC.Base.Functor LibCore.Models.AKeyword
instance GHC.Base.Applicative LibCore.Models.AKeyword


module LibCore.KnowledgeBase
type KnowledgeBaseStructure = Map Keyword Keyword

-- | Build a new Knowledge Base from the supplied keyword pair list.
build :: [(Keyword, Keyword)] -> KnowledgeBaseStructure

-- | Get the list of all the stored records in the Knowledge Base.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; testKB = build [(pure "brb", pure "be right back")]
--   
--   &gt;&gt;&gt; listAll testKB
--   [(Key {keyword = "brb", plural = False},Key {keyword = "be right back", plural = False})]
--   </pre>
listAll :: KnowledgeBaseStructure -> [(Keyword, Keyword)]

-- | Retrieve a single element by its keyword.
--   
--   Examples
--   
--   <pre>
--   &gt;&gt;&gt; testKB = build [(pure "brb", pure "be right back")]
--   
--   &gt;&gt;&gt; get testKB $ pure "brb"
--   Right (Key {keyword = "be right back", plural = False})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; get testKB $ pure "beb"
--   Left (StandardError "no record found for this keyword : Key {keyword = \"beb\", plural = False}")
--   </pre>
get :: KnowledgeBaseStructure -> Keyword -> Either Error Keyword

-- | Add new item to the Knowledge Base. Adds the item to the KB as a new
--   record if the key was notseen before, and replaces the existing record
--   otherwise.
--   
--   Examples
--   
--   <pre>
--   &gt;&gt;&gt; testKB = build [(pure "brb", pure "be right back")]
--   
--   &gt;&gt;&gt; add testKB (pure "btw") (pure "by the way")
--   (Key {keyword = "by the way", plural = False},fromList [(Key {keyword = "brb", plural = False},Key {keyword = "be right back", plural = False}),(Key {keyword = "btw", plural = False},Key {keyword = "by the way", plural = False})])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; add testKB (pure "btw") (pure "by the way!")
--   (Key {keyword = "by the way!", plural = False},fromList [(Key {keyword = "brb", plural = False},Key {keyword = "be right back", plural = False}),(Key {keyword = "btw", plural = False},Key {keyword = "by the way!", plural = False})])
--   </pre>
add :: KnowledgeBaseStructure -> Keyword -> Keyword -> (Keyword, KnowledgeBaseStructure)

-- | Updates the record at given key with the new value. Only full updates
--   are supported. If the key is not in the KB, returns an error.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; testKB = build [(pure "brb", pure "be right back")]
--   
--   &gt;&gt;&gt; put testKB (pure "brb") (pure "BE RIGHT BACK")
--   Right (Key {keyword = "BE RIGHT BACK", plural = False},fromList [(Key {keyword = "brb", plural = False},Key {keyword = "BE RIGHT BACK", plural = False})])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; put testKB (pure "btw") (pure "by the way!")
--   Left (StandardError "no record found for this keyword : Key {keyword = \"btw\", plural = False}")
--   </pre>
put :: KnowledgeBaseStructure -> Keyword -> Keyword -> Either Error (Keyword, KnowledgeBaseStructure)

-- | Removes an existing item at the given key form the Knowledge Base. If
--   the key is not present, return as error.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; testKB = build [(pure "brb", pure "be right back")]
--   
--   &gt;&gt;&gt; remove testKB $ pure "brb"
--   Right (fromList [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; remove testKB $ pure "btw"
--   Left (StandardError "no record found for this keyword : Key {keyword = \"btw\", plural = False}")
--   </pre>
remove :: KnowledgeBaseStructure -> Keyword -> Either Error KnowledgeBaseStructure


module LibCli.Adapters

-- | <a>KbEntry</a> is an entry on the file containing the Knowledge Base.
data KbEntry
KbEntry :: String -> String -> KbEntry
[abbreviation] :: KbEntry -> String
[expansion] :: KbEntry -> String

-- | <a>mapEntries</a> maps entries to a pair of (<a>abbreviation</a>,
--   <a>expansion</a>)
--   
--   <pre>
--   &gt;&gt;&gt; mapEntries (KbEntry { abbreviation = "abbr", expansion = "abbreviation" })
--   (Key {keyword = "abbr", plural = False},Key {keyword = "abbreviation", plural = False})
--   </pre>
mapEntries :: KbEntry -> (Keyword, Keyword)

-- | <tt>mapKeywords</tt> maps keyword pairs to their entries
mapKeywordPair :: (Keyword, Keyword) -> KbEntry

-- | <a>getKnowledgeBase</a> parses from a CSV file to a
--   <tt>KnowledgeBaseStructure</tt>.
getKnowledgeBase :: Vector KbEntry -> KnowledgeBaseStructure
instance Data.Csv.Conversion.FromNamedRecord LibCli.Adapters.KbEntry
instance Data.Csv.Conversion.ToNamedRecord LibCli.Adapters.KbEntry
instance Data.Csv.Conversion.DefaultOrdered LibCli.Adapters.KbEntry


module LibCore.Parser
type ParseStructure = [Token]

-- | The abbreviation symbol. Can later be made configurable
abbSymbol :: String

-- | The plural symbol. String between the abbSymbol and the pluralSymbol
--   are interpreted as plurals
pluralSymbol :: String

-- | Given a string, parse it. This function can throw an error if parsing
--   fails
doParse :: String -> ParseStructure

-- | Map a string to a list of Tokens. For example: &gt;&gt;&gt; parseInput
--   "@<tt>bob" Right [DoMap (Key {keyword = "bob", plural = False})]
--   &gt;&gt;&gt; parseInput "</tt>@fw's" Right [DoMap (Key {keyword =
--   "fw", plural = True})] &gt;&gt;&gt; parseInput "hello!" Right [NoToken
--   "hello!"]
parseInput :: String -> Either ParseError ParseStructure

-- | The main parser tries to consume all input into a ParseStructure,
--   given an | abbreviation symbol and a plural symbol
mainParser :: String -> String -> Parser ParseStructure

-- | Inverse of the <a>isSpace</a> function from Data.Char
notSpace :: Char -> Bool

-- | Given an abbreviation string s and a plural end string p, parse the
--   string between it
pluralAbbrParser :: String -> String -> Parser Token

-- | Given an abbreviation string s, parse the string after it
abbrParser :: String -> Parser Token

-- | Parse any string into a token
noAbbrParser :: Parser Token

-- | Parser to process punctuation. We added this because abbreviations
--   followed by | punctuation without a space, such as 'hello!' were
--   parsed as NoToken
punctuationParser :: Parser Token

-- | Parse spaces. We handle spaces separate because they are word
--   delimiters
spaceParser :: Parser Token

-- | Given a predicate, parse a character into a NoToken
noTokenParser :: (Char -> Bool) -> Parser Token


module LibCore.Mapper

-- | Map a ParseStructure using a KnowledgeBaseStructure to another
--   ParseStructure. The structure of this function makes it possible to
--   apply multiple KnowledgeBases to one ParseStructure
mapParseStructure :: KnowledgeBaseStructure -> ParseStructure -> ParseStructure

-- | Lookup a token in the KnowledgeBaseStructure. If it is not found,
--   return the lookup token. Otherwise, it returns the result of the
--   lookup, which is also a token
doLookup :: KnowledgeBaseStructure -> Token -> Token


module LibCore.Decoder

-- | The main entry point to convert a ParseStructure into a String
decode :: ParseStructure -> String

-- | tokenToString maps each token class to a string representation
tokenToString :: Token -> String


module LibCli.HandlerUtils

-- | Function to load the Knowledge Base from the specified file. Supports
--   only CSV files.
loadKb :: FilePath -> IO (Either Error KnowledgeBaseStructure)

-- | Function to load the abbreviation input file. Can be any file with
--   contents loadable as String.
loadInput :: FilePath -> IO (Either Error String)

-- | Performs the expansion logic on the provided string.
doExpansion :: KnowledgeBaseStructure -> String -> IO String

-- | Pretty prints the Keyword pair (key, value) from the Knowledge Base
formatRecord :: (Keyword, Keyword) -> String

-- | Dumps the Knowledge Base to the specified file path. Writes the KB out
--   in CSV format.
dump :: FilePath -> KnowledgeBaseStructure -> IO ()

-- | Given a FilePath and a string, write the string to the FilePath.
--   Throws an error if no valid path is specified. Write the given string
--   to the file path otherwise.
returnOutput :: FilePath -> String -> IO ()

-- | Gets the pair of paths to use depending on the flag. Returns an error
--   if a pair of (Input, Output) file paths is not possible. Otherwise,
--   returns the pair of file paths in the following order: (Input,
--   Output).
getInOutFilePaths :: Maybe FilePath -> Maybe FilePath -> Bool -> Either Error (FilePath, FilePath)

-- | Handles the retrieval of Knowledge Base file paths. If nothing is
--   provided, raises an error. Otherwise, returns the given file path.
getKnowledgeBaseFilePath :: Maybe FilePath -> Either Error FilePath

-- | Handles possible errors from retrieving file paths.
getFilePaths :: Either Error a -> IO a


module LibCli.Handlers

-- | Expand command handler. Deal with single input expansion without
--   reading an input file.
expandHandler :: Maybe FilePath -> String -> IO ()

-- | Replace command handler. Does all the replacing heavy-lifting. Loads
--   the required files, produces the expansions and writes the output
--   file.
replaceHandler :: Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Bool -> IO ()

-- | Add command handler. Adds new abbreviation with the associated
--   expansion to the KB.
addHandler :: Maybe FilePath -> String -> String -> IO ()

-- | Update command handler. Updates an existing abbreviation in the KB.
updateHandler :: Maybe FilePath -> String -> String -> IO ()

-- | Delete command handler. Deletes an existing abbreviation from the KB.
deleteHandler :: Maybe FilePath -> String -> IO ()

-- | List command handler. Displays all the contents of the specified
--   Knowledge base.
listHandler :: Maybe FilePath -> IO ()


module LibCli.Main

-- | The main controller of the ShortHndr CLI interface. Connects the
--   provided CLI commands with their respective handlers.
cliController :: ShortHndr -> IO ()

-- | Main entrypoint of the CLI application.
--   
--   <i>CLI endpoints:</i>
--   
--   <ul>
--   <li>replace - expand all the abbreviation in the full text file</li>
--   <li>expand - find an expansion for a single abbreviation input</li>
--   <li>list - list all the known expansion records</li>
--   <li>add - add a new record to the knowledge base</li>
--   <li>update - modify an existing record in the knowledge base</li>
--   <li>delete - delete an existing record from the knowledge base</li>
--   </ul>
--   
--   <i>Usage:</i>
--   
--   <ul>
--   <li>--help - prints the full CLI tool support</li>
--   <li>&lt;command&gt; [args*] [options*] - invokes the command</li>
--   </ul>
--   
--   <i>See more:</i>
--   
--   <ul>
--   <li>See <a>Spec</a> for more information about the CLI endpoints.</li>
--   </ul>
cliMain :: IO ()
